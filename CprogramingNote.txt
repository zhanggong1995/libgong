线程通信: 
	1.管道pipe：数据量小
	2.信号:
	终止另一个进程:pthread_cancel (pthread_t thread) ;
				   pthread_kill(pthread_t thread,SIGNO)
网络编程部分:
	udp客户端端口不同，收不到数据----------------bind本地源端口
	获取非本地ip地址:通过socket_in 结构体：inet_ntoa(from.sin_addr)
				端口:ntohs(from.sin_port)
	inet_aton将__cp指向的字符串转成网络序的地址存在__inp指向的地址结构。
		成功返回1，否则返回0。(据书中所说，如果__inp指针为空，
		那么该函数仍然对输入字符串进行有效性检查但是不存储任何结果）
	inet_addr功能和inet_aton类似，但是inet_addr出错时返回INADDR_NONE常值
		（通常是32位均为1的值），这就意味着至少有一个IPv4的地址（通常为广播地址255.255.255.255）
		不能由该函数处理。建议使用inet_aton代替inet_addr。
	inet_ntoa将网络序二进制IPv4地址转换成点分十进制数串。该函数的返回值
		所指向的字符串驻留在静态内存中。这意味着该函数是不可重入的。
		同时我们也该注意到该函数以一个结构体为参数而不是常见的以一个结构体指针作为参数。
	子线程如何使用父线程创建的socket？还是说使用fork()更好？
		socket在栈空间开辟无法传递-----------可以传递文件描述符
	socket端口复用(bind error)int opt = 1;  
		setsockopt( sockfd_one,SOL_SOCKET,SO_REUSEADDR, (const voidvoid *)&opt, sizeof(opt) ); 
		setsockopt(sockfd,SOL_SOCKET,SO_KEEPALIVE,(const char*)&bSet,sizeof(int));				
如何存储IP地址到字符串？------char *p=inet_ntoa(from.sin_addr);

交叉编译-----arm-linux-gnueabihf-gcc -lpthread
16进制字符串 "213150575230310d"  如何变为字符串数组 "0x21,0x31,0x50..."

jason文件的处理：--cJson库，编译 -ml
	char buffer[40960]={0};
	FILE* pFile=fopen("FILENAME", "r");
	int file_size = ftell(pFile);
	result = fread(buffer, 1, file_size, pFile);
	buffer[file_size] = '\0';
    	fclose(pFile);
	cJSON *root = cJSON_Parse(buffer);
	cJSON *inst = cJSON_GetObjectItem(root, "inst");
	int array_size = cJSON_GetArraySize(inst);
字符串处理:	 
	scanf,sscanf,fscanf
	printf,sprintf,fprintf
	sscanf()
	{	sscanf() 的作用：从一个字符串中读进与指定格式相符的数据.http://blog.csdn.net/sjf0115/article/details/8579935
		int sscanf (const char *str,const char * format,........);
	}

 current_APP_IP.s_addr = adr_clnt.sin_addr.s_addr;
kill -9 $(pidof ivc)//结束进程


-----------9.29------------
Ubuntu 14.04更新源遇到问题
W: Failed to fetch http://ubuntu.srt.cn/ubuntu/dists/trusty-backports/Release.gpg  Unable to connect to ubuntu.srt.cn:http:
W: Some index files failed to download. They have been ignored, or old ones used instead.

更改源为阿里源：
	deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse 
	deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse 
	deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse 
	deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse 
	deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 
	deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse 
	deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse 
	deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse 
	deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse 
	deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse
//  /etc/apt/sources.list

sudo geany /etc/resolv.conf 

	# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)
	#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
	nameserver 127.0.1.1
	#这里用的是阿里云的DNS服务器
	nameserver 223.5.5.5  
	nameserver 223.6.6.6
sudo apt-get update成功
sudo apt-get install ntp
--ntpclient下载地址:（root@ubuntu:~/zhanggong/ntp_clinet/ntpclient-2015#）
http://doolittle.icarus.com/ntpclient/
解压，修改Makefile:
	# To cross-compile  
	  CC = arm-linux-gnueabihf-gcc  //取消注释
make，得到 ntpclient，复制到开发板
执行：
	export TZ=CST-8									//改变环境变量（中国东8时区）
	./ntpclient -s -d -c 1 -i 5 -h 202.108.6.95		//中国授时区
	
	
	（参数意义）：
-c count count时间计数后停止（默认为0意味直到永远）
-d      打印诊断（功能可以在编译时关闭）
-g 选项会导致程序NtpClient后得到的结果更准确，而不仅仅是（微秒，默认为0意味直到永远停止）
-h 主机名（强制）NTP服务器，对系统时间来衡量
-i 间隔时间 每隔一定时间检查时间（默认值为600）
-I 尝试服务器使用adjtimex锁定本地时钟（2）
-p 端口名  锁定本地NTP客户端UDP端口（默认为0表示“任何可用的”）
-q 最小延时分钟 最小数据包的延迟交易（默认800微秒）
-r 在标准输入重播分析代码
-s 简单的时钟设置（相当于-c 1）
-t 信任网络和服务器，没有RFC-4330推荐使用的检查
------------------------------------------------
------------------10.9--------------------------
更改run.sh文件：

/etc/profile：
	export TZ=CST-8
	chmod 755 /home/root/IVC/settime
	chmod 755 /home/root/IVC/ntpclient
	/home/root/IVC/settime &
即.sh文件：
echo 'export TZ=CST-8' >> /etc/profile
echo 'chmod 755 /home/root/IVC/settime' >> /etc/profile
echo 'chmod 755 /home/root/IVC/ntpclient' >> /etc/profile
echo '/home/root/IVC/settime &' >> /etc/profile
	//10.9只修改了profile文件
	//将ntpclient settime拷至IVC文件夹即可
-------------------------------------------------------
------------------10.10--------------------------
程序在后台运行：./*** & 		*/
链表操作返回值返回head(否则可能无法实现改变链表的操作)

------------------10.18--------------------------
FTP协议：http://blog.csdn.net/sun_wangdong/article/details/45868615
sscanf用法(str,format...)
sprintf用法
strcat(dst,src);字符串拼接
------------------10.19--------------------------
网络编程基础熟练度：
服务器端：
int servfd；
struct  sockaddr_in servaddr
socket
	bzero( & servaddr, sizeof (servaddr));
    servaddr.sin_family=AF_INET;
    servaddr.sin_port=htons(port);
    servaddr.sin_addr.s_addr=htons(INADDR_ANY);
bind
listen
accept
	while(1)
	{
		send...
		recv>=0...//注：客户端关闭时向服务器发送0字节数据，不要忘记recv=0
	}
close
------------------10.23--------------------------


----------------------品牌配置文件上传到服务器  
----------------------ivc与守护进程通信         tcp通信
----------------------ivc目录只留下ivc一个文件  ok
----------------------设备串号一同上传到服务器  ok

------------------10.26--------------------------
任务目的：
为了兼容更多品牌的控制面板

任务背景：
程序里有个线程rs485_receive_thread 用来接收端口fd_COM[4]的信息，
这个端口对应外部接口是485接口，485连接着控制面板和灯光模块，
当前这个端口的配置参数是固定为9600，8，1，N 。 rs485_receive_thread  
接收线程会把接收到的数据跟预存在command_scense_panel 数组里的数据进行对比，
再决定执行哪个命令。  
注意：使用ikontrol灯光模块时，发送命令也是通过这个端口。

任务内容：
1.  把控制面板的通信参数，也就是fd_COM[4]端口接收状态时的参数和需要响应的命令做成码表文件，
控制面板的设备类型为"CP",  
2. 同一个端口fd_COM[4]上发送和接收可以采用不同参数，线程启动时采用CP控制面板码表文件的参数，
默认处于接收状态，发送命令时采用LIGHTS设备码表文件的参数，发送完成后恢复到接收命令的码表文件参数。
截止时间：11月03日 周五 17:00

1.灯光模块和面板是否会同时使用
2.面板接线
3.
int fd = open("/dev/ttyS0", O_RDWR | O_NOCTTY | O_NONBLOCK);
 
//声明一个 fd_set 集合来保存我们要检测的 句柄
fd_set readfd;
//清空readfd与所有文件句柄的联系
FD_ZERO(&readfd);
//建立文件句柄fd与readfd的联系
FD_SET(fd, &readfd);
 
//接收数据缓冲区
char buf_receive[BUF_MAX_LEN];
 
for(;;)
{
    //若串口可读写
    if(FD_ISSET(fd, &readfd))
    {
        int nread = read(fd, buf_receive, BUF_MAX_LEN);
        //在此处就接收到了发送方传过来的数据，建议将数据放到一个队列中方便处理
    }
    else{
        printf("the serial port can not to read\n");
        return 0;
    }
}
http://bbs.csdn.net/topics/390527497

------------------10.28--------------------------
#define HARDWARE_TYPE "BOT-MR"为正式版本
#define HARDWARE_TYPE "BOT-MK"为测试版本
.sh脚本文件：传入Linux系统中会出现^M,注意跨系统编辑，传输文件可能出现由于回车编码不同导致的多余符号


------------------10.31--------------------------
access函数

指针指向固定字符串不可以用sprintf，会出现段错误
宏开关
#ifdef TEST
	#define HARDWARE_TYPE "BOT-MK"
#else 
	#define HARDWARE_TYPE "BOT-MR"
#endif

	select
	int retval, maxfd = -1;
	 
	fd_set rfds;
	struct timeval timeout = {3,0};
	FD_ZERO(&rfds);
	//FD_SET(0, &rfds);
	maxfd = 0;
	FD_SET(sockfd, &rfds);
	if (sockfd > maxfd)
		maxfd = sockfd;
	retval = select(maxfd + 1, &rfds, NULL, NULL, &tv);//多路复用收发指令到被控设备
	if (retval == -1) 
		error;
	else 
	{
		if (FD_ISSET(sockfd, &rfds)) //有设备指令待接收				
		{read}


串口波特率的修改:
stty -F /dev/ttyO2

stty -F /dev/ttyO1 ispeed 14400 ospeed 14400 cs8

加密算法

异或
https://wenku.baidu.com/view/4ab46466a5e9856a561260c9.html

------------------11.30--------------------------
Linux文件系统构成：
	https://www.cnblogs.com/wen858636827/archive/2012/12/26/2834373.html

	fprintf(fp, "%d", buffer); 是将格式化的数据写入文件
	fprintf(文件指针,格式字符串,输出表列);
	fwrite(&buffer, sizeof(int), 1, fp);是以二进位方式写入文件
	fwrite(数据，数据类型大小（字节数），写入数据的最大数量，文件指针);
boa服务器：
	配置文件路径：/etc/boa/boa.conf
	配置详解 http://blog.csdn.net/xxgxgx/article/details/51034652
	默认根路径/usr/httproot/
	cgi脚本目录/usr/httproot/cgi-bin
	
------------------12.25---------------------------
tail -f xxx 显示文件尾10行并实时更新

------------------12.25---------------------------
动态二维数组
	command_scense_panel=(char **)malloc(sizeof(char*)*8);//共有8种模式 
	for(j=0;j<8;j++)
	{
		command_scense_panel[j]=(char*)malloc(sizeof(char) * (len+20)); //防止指令长度不同
		bzero(command_scense_panel[j],(len+20));
	}	

串口接收数据后需要usleep();
------------------12.29---------------------------
大数处理用数组
char '1'= 0x31;
int char类型转换用sprintf

-------------------1.4----------------------------
strcspn(const char *s, const char * reject);返回首次出现reject的位置n
	#include <string.h>
	main()
	{
		char *str = "Linux was first developed for 386/486-based pcs. ";
		printf("%d\n", strcspn(str, " "));
		printf("%d\n", strcspn(str, "/-"));
		printf("%d\n", strcspn(str, "1234567890"));
	}
	执行结果：
	5 //只计算到" "的出现, 所以返回"Linux"的长度
	33 //计算到出现"/"或"－", 所以返回到"6"的长度
	30 // 计算到出现数字字符为止, 所以返回"3"出现前的长度
char *strrchr(const char *str, char c);查找一个字符c在另一个字符串str中末次出现的位置
	 从文件路径中提取文件名：
	char fn[100];
	char fp[500] = "/host/HY/linux/GTK/HTYPaint/bear.jpg";
	char *ptr = strrchr(fp, '/');
	sprintf(fn,"%s",ptr+1);
	运行结果：fn="bear.jpg"
extern char *strstr(char *str1, const char *str2);
	char str[]="1234xyz";
	char *str1=strstr(str,"34");
	cout << str1 << endl;
	显示的是: 34xyz

int getopt(int argc,char * const argv[ ],const char * optstring);	
-------------------1.16----------------------------
%运算符
	小数%大数=小数本身

char *strstr(const char *str1, const char *str2);
	#include<string.h>
	找出str2字符串在str1字符串中第一次出现的位置（不包括str2的串结束符）。返回该位置的指针，如找不到，返回空指针。

	Arduino-IRremote  
		红外遥控库  https://github.com/z3t0/Arduino-IRremote 

		下面是网友对这个库的一个修改
http://www.geek-workshop.com/thread-12401-1-1.html 
-------------------1.25----------------------------
Linux加载u盘
fdisk -l
mkdir /mnt/usb
如果是fat16就使用下面指令：
  mount Ct msdos /dev/sd** /mnt/usb 
  如果是fat32：
  mount Ct vfat /dev/sd** /mnt/usb 
  如果是ext2：  
  mount Ct ext2 /dev/sdb1 /mnt/usb 
sd**
卸载：
umount /dev/sdb1或umount /mnt/usb
-------------------1.29----------------------------
自动挂载u盘
udev功能：
http://blog.csdn.net/mike8825/article/details/51000220
http://blog.sina.com.cn/s/blog_4a70d5d901012nns.html
配置文件在/etc/udev/rules.d，相关规则查阅 man udev
自动挂载：
  1、在/etc/udev/rules.d目录里面创建11-usb-mount.rules，
         11-usb-mount.rules里面的内容如下：
              ACTION!="add",GOTO="farsight"
              KERNEL=="sd[a-z][0-9]",RUN+="/sbin/mount-usb.sh %k"
              LABEL="farsight"
 2、  在/sbin/目录里创建mount-usb.sh脚本文件
        mount-usb.sh的内容如下：
              #!/bin/sh
              /bin/mount -t vfat /dev/$1 /tmp
              sync
重启下即可在linux上实现自动挂载，u盘自动挂载到/tmp目录里
自动卸载：
  1、在/etc/udev/rules.d目录里面创建11-usb-mount.rules，内容如下：
        ACTION!="remove",GOTO="farsight"
       SUBSYSTEM!="block",GOTO="farsight"
        KERNEL=="sd[a-z][0-9]",RUN+="/sbin/umount-usb.sh"
        LABEL="farsight"
   2、在/sbin/目录里创建umount-usb.sh脚本文件
           mount-usb.sh的内容如下：
                     ACTION!="remove",GOTO="farsight"
                     SUBSYSTEM!="block",GOTO="farsight"
                     KERNEL=="sd[a-z][0-9]",RUN+="/sbin/umount-usb.sh"
                     LABEL="farsight"
#未测试
upnp论坛：
http://www.upnp.org/specs/arch/UPnP-arch-DeviceArchitecture-v1.1.pdf
-------------------2.26----------------------------
1下载lua5.2.4，安装报错缺少依赖包libreadline-dev：
	readline/readline.h: No such file or directory
	apt-get install libreadline-dev 提示 Could not resolve 'mirrors.aliyun.com'
2修改dns:
{
	1,重启生效：

	sudo vi /etc/resolvconf/resolv.conf.d/base（这个文件默认是空的）
	在里面插入：
	nameserver 8.8.8.8
	nameserver 8.8.4.4
	如果有多个DNS就一行一个
	修改好保存，然后执行
	sudo resolvconf -u
	再看/etc/resolv.conf，最下面就多了2行：
	cat /etc/resolv.conf
		# Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(
8)

		#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
		nameserver 8.8.8.8
		nameserver 8.8.4.4
	可以看到我们的设置已经加上了，然后再ping一个域名，当时就可以解析了，无需重启。

	2，重启失效：

	配置文件地址 /etc/resolv.conf

	使用编辑器打开

	改为如下内容：
	search localdomain
	nameserver 202.96.128.86 希望修改成的DNS
	nameserver 202.96.128.166 备用DNS

	重启网络：sudo /etc/init.d/networking restart。
}
3再次安装libreadline-dev
4安装lua:
	make linux test
	make install
lua -i
	Lua 5.2.4  Copyright (C) 1994-2015 Lua.org, PUC-Rio
	> 

完成
lua手册：http://www.runoob.com/manual/lua53doc/
--创建软连接
	ln -s /lua/lua5.2.4/src/lua /usr/bin/lua
	删除软连接
	rm -rf ./lua
-------------------3.1----------------------------
C语言调用lua脚本
http://www.cnblogs.com/pied/archive/2012/10/26/2741601.html
1.	locate 指令 查找文件或者目录
	updatedb  更新数据库（Linux文件目录）
2.	安装了liblua-dev 依赖包
	sudo apt-get install lua5.1-policy-dev 

3.gcc -l -i -L
	-I /home/hello/include，表示将/home/hello/include
目录作为第一个寻找头文件的目录，

寻找的顺序是：/home/hello/includeC>/usr/includeC>/usr/local/include
也就是指定优先查找的目录，找不到的话查找默认目录

	-L /home/hello/lib，表示将/home/hello/lib目录作为第一个寻找库文件的目录， 
寻找的顺序是：/home/hello/libC>/libC>/usr/libC>/usr/local/lib
同上，也是指定优先查找的目录

	-l word , 表示**寻找动态链接库文件**libword.so
（也就是文件名去掉前缀和后缀所代表的库文件)

如果 加上编译选项-static，表示寻找静态链接库文件，也就是libword.a
例：
	gcc -o hello hello.c   -I/home/hello/include   -L/home/hello/lib    -lworld
-------------------3.2----------------------------
C语言编译成库
	gcc mylib.c -fPIC -shared -o mylib.so -Wall
	-w的意思是关闭编译时的警告，也就是编译后不显示任何warning
，因为有时在编译之后编译器会显示一些例如数据转换之类的警告，

这些警告是我们平时可以忽略的。
	
	-Wall选项意思是编译后显示所有警告。

	-W选项类似-Wall，会显示警告，但是只显示编译器认为会出现错误的警告。
遗留问题：----------------------------------------------------------------
1.bit byte区别

2.回调函数

3.异步 同步

4.epoll

5.Linux读取U盘
	磁盘挂载，格式化
6.log打印信息通过define关闭/打开？（通过控制宏定义来控制打印信息）
	#ifdef #ifndef #endif
7.系统时间和网络同步问题
	通过客户端连接ntp服务器同步
8.服务器语言

9.设备与服务器沟通（外网）
	web服务器
10.Linux开机启动程序的设置
	profile文件，rcX.d 等文件
11.脚本语言  shell脚本
	chmod +x ***.sh
	./sh
12.当前进程execve调用后printf无法打印到屏幕

13.串口通信的read是否阻塞，以及select模型

14.终端，伪终端，重定向>,tty终端，printf输出标准设备，标准文件描述符

15.Makefile规则

16.文件指针问题


